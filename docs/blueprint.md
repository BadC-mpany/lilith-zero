# Sentinel Blueprint v1.0

# **Goal:**

The goal is to establish a Zero Trust security layer by routing all agent tool requests through a cloud-hosted Interceptor (implemented as a LangChain tool wrapper) that cryptographically binds permissions to specific parameters using Ed25519 signatures, creating an unforgeable chain of custody.

By strictly isolating the untrusted agent client from the sensitive MCP execution environment and maintaining a real-time ledger of session taints, the architecture renders client-side bypass, replay attacks, and data exfiltration practically impossible.

Ultimately, this provides a seamless Security-as-a-Service platform where developers define immutable rules in the cloud, while a lightweight SDK transparently enforces governance without exposing private infrastructure to the public internet.

# Description

**Description of Sentinel v1.0 for the Secure Deterministic Interceptor Architecture**. It utilizes the **Trusted-Binding-Proxy (TBP)** model to ensure Zero Trust enforcement, effectively rendering client-side bypass and replay attacks impossible through strict infrastructure isolation and cryptographic binding.

---

### I. Architectural Topology & Network Isolation

The system is strictly segmented into three specific trust zones. Security is enforced not just by software logic, but by network topology.

1. **Zone A: The Untrusted Client (Public Internet)**
   - **Component:** LangChain Agent Runtime.
   - **Trust Level:** Zero.
   - **Context:** Contains the LLM inference engine and the Agent Logic.
   - **Capabilities:** It holds an infrastructure-injected **API Key**. It has _no knowledge_ of the MCP Server's existence, IP, or URL. It can only communicate with the Interceptor.
2. **Zone B: The Policy Enforcement Point (DMZ / Public Subnet)**
   - **Component:** The Interceptor Service (The "Conscience").
   - **Trust Level:** High (Authoritative).
   - **Capabilities:** Terminates TLS from Zone A. Holds the **Policy Database** (Rules) and the **Private Signing Key** (Ed25519-SK). It acts as a transparent Reverse Proxy.
   - **State:** Connected to a high-speed, persistent Redis cluster for **Taint Tracking**.
3. **Zone C: The Execution Environment (Private VPC)**
   - **Component:** MCP Server.
   - **Trust Level:** Verified Execution Only.
   - **Capabilities:** Holds the **Public Verifying Key** (Ed25519-PK).
   - **Network Constraint:** Strictly **Air-Gapped** from the Public Internet. Ingress is allowed _only_ from the Zone B (Interceptor) IP address via mTLS (Mutual TLS).

---

### II. Component 1: The Secure LangChain Tool Wrapper

_The "Blind Courier"_

The wrapper is a lightweight client designed to be functionally dumb regarding security to prevent logic tampering.

**Technical Specification:**

- **Input Handling:** Accepts the `tool_name` and `arguments` dictionary generated by the LLM.
- **Identity Injection:** On instantiation, it loads the `INTERCEPTOR_API_KEY` from the container's environment variables. This key is never exposed to the LLM context window.
- **Payload Construction:** It wraps the LLM's intent into a structured JSON envelope: `{ "session_id": UUID, "tool": string, "args": dict }`.
- **Transport:** Sends a standard HTTPS POST request to the Interceptor.
- **Blindness:** It handles standard HTTP errors (401/403) but receives no detailed logic about _why_ a rule failed, preventing "Rule Probing" by an adversarial LLM.

---

### III. Component 2: The Interceptor (Policy Engine)

_The "Stateful Firewall"_

This is the core logic unit. It implements a Deterministic State Machine to approve or deny requests.

### A. The Immutable Policy Schema

Policies are stored server-side (PostgreSQL/DynamoDB), indexed by the Client's API Key. The Agent cannot modify this.

- **Static Rules (ACL):** A whitelist/blacklist map.
  - _Structure:_ `Map<ToolName, PermissionLevel>`
  - _Example:_ `delete_database: DENY`, `read_file: ALLOW`.
- **Dynamic Rules (Taint Logic):**
  - _Transition Rule:_ `If Tool X is executed -> Apply Taint Tag Y`.
  - _Gating Rule:_ `If Session has Taint Tag Y -> Block Tool Z`.
  - _Example:_ `read_private_file` adds `taint:confidential`. `web_search` requires `NOT taint:confidential`.

### B. The Verification Algorithm (Pseudo-Logic)

Upon receiving a request:

1. **Authenticate:** Validate `X-API-Key` header against the Customer DB. Retrieve the associated Policy and the hidden Upstream MCP URL.
2. **Canonicalize:** Apply RFC 8785 (JCS) to the incoming `args`.
3. **Load State:** Fetch the `Set<Taints>` for the given `session_id` from Redis.
4. **Evaluate:**
   - _Check 1:_ Is `tool_name` allowed in Static ACL?
   - _Check 2:_ Does `Set<Taints>` contain any tag listed in the `tool_name`'s "Forbidden Tags" list?
5. **State Transition:** If Approved, identify if `tool_name` generates new taints. Append these to Redis (Atomic `SADD`).
6. **Mint:** Generate the Cryptographic Capability (detailed below).
7. **Proxy:** Open a secure tunnel to the upstream MCP Server, injecting the Capability Token into the headers.

---

### IV. Component 3: Immutable Cryptographic Minting

_The "Binding Mechanism"_

To prevent TOCTOU (Time-of-Check to Time-of-Use), we mathematically bind the permission to the exact parameters.

**Cryptographic Primitive:** Ed25519 (EdDSA).

- _Why?_ It offers high performance, small signature size, and resistance to side-channel attacks compared to RSA.

The Token Structure (JWS):

The Interceptor mints a JWT with the following strict claims:

- `iss` (Issuer): `interceptor-v1`
- `sub` (Subject): `session_uuid`
- `scope`: `tool:{tool_name}`
- `p_hash`: **The Parameter Anchor.**
  - _Algorithm:_ `SHA-256( Canonicalize( arguments_dict ) )`
  - _Canonicalization:_ Keys sorted lexicographically, no whitespace. This ensures `{"a":1, "b":2}` hashes identically to `{"b":2,"a":1}`.
- `jti` (Nonce): A version-4 UUID.
- `exp` (Expiry): `Current_Time + 500ms`.
  - _Note:_ The TTL is ultra-short because the Interceptor proxies the request immediately. This creates a negligible window for replay attacks.

---

### V. Component 4: The MCP Server Integration

_The "Skeptical Executor"_

The MCP Server is configured to trust nothing but a valid Ed25519 signature from the Interceptor.

**The Verification Pipeline:**

1. **Gateway Check:** Accept connection only if source IP matches Interceptor allowlist (or mTLS certificate is valid).
2. **Signature Verification:** Decode the JWT header. Validate the Ed25519 signature using the Interceptor's Public Key.
3. **Replay Protection (The "Burn" List):**
   - Extract `jti` from token.
   - Check local Redis/Memory cache: `Exists("used_nonce:" + jti)?`
   - If yes -> **REJECT** (Replay Attempt).
   - If no -> Store `jti` with a TTL matching the token's `exp`.
4. **Parameter Integrity (The Anti-TOCTOU Check):**
   - Take the _received_ raw arguments.
   - Run `SHA-256( Canonicalize( received_args ) )`.
   - Compare result against the `p_hash` claim inside the Token.
   - If mismatch -> **REJECT** (Data Tampering).
5. **Execution:** Only if all checks pass, the tool function is invoked.

---

### VI. Summary of Attack Mitigations

| **Threat**                  | **Architectural Defense**                                                                                                                                                          |
| --------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Client-Side Bypass**      | Impossible. The Agent does not have the MCP URL. It cannot route packets to the execution environment.                                                                             |
| **Policy Manipulation**     | Impossible. Policies are stored on the Interceptor's database, not in the Agent's request payload.                                                                                 |
| **Replay Attacks**          | Mitigated via `jti` caching (Nonce "Burn" list) and ultra-short (sub-second) Token TTL.                                                                                            |
| **TOCTOU / Param Swapping** | Mitigated via `p_hash` binding. If parameters change between Interceptor and MCP, the hash check fails.                                                                            |
| **Context Pollution**       | Mitigated via **Stateful Taint Tracking**. The Interceptor remembers if sensitive data was accessed and dynamically blocks exfiltration tools (e.g., web search) for that session. |
| **Key Theft**               | The Interceptor's Private Signing Key is never exposed. If the Agent's API Key is stolen, the attacker is still bound by the Server-Side Policy limits.                            |

# Implementation

### The Prototype Architecture

This MVP implements the **Trusted-Binding-Proxy (TBP)** model.

1. **Network Isolation:** We simulate three distinct zones using different local ports.
   - **Zone A (Client/Agent):** Runs as a script. Has the API Key. Knows _only_ the Interceptor URL.
   - **Zone B (Interceptor):** `localhost:8000`. Holds the Policy DB, Private Key, and Taint Ledger (Redis).
   - **Zone C (MCP Server):** `localhost:9000`. Holds the Public Key. Trusts _only_ requests signed by the Private Key.
2. **The Logic Flow:**
   - The Agent requests `read_file`.
   - Interceptor checks rules. If allowed, it mints a token binding the arguments `{"path": "secret.txt"}` to the signature.
   - Interceptor _proxies_ the request to the MCP server.
   - MCP verifies the signature and the argument hash.
   - Result is returned to Interceptor, which logs side-effects (Taints) and returns data to Agent.
3. **Requirements:**
   - Python 3.9+
   - Redis (running locally on default port 6379)
   - Libraries: `fastapi`, `uvicorn`, `pydantic`, `pyjwt`, `cryptography`, `redis`, `httpx`, `langchain`

**Implementation Plan:**

1. **`sentinel_core.py`**: Shared cryptographic utilities (Canonicalization & Hashing).
2. **`keygen.py`**: Utility to generate Ed25519 keys for the prototype.
3. **`interceptor_service.py`**: The SaaS Policy Engine & Proxy.
4. **`mcp_server.py`**: The Tool Host with the Security Verifier middleware.
5. **`sentinel_sdk.py`**: The Client-side LangChain Tool Wrapper.
6. **`demo_agent.py`**: A simulation script showing both valid usage and a blocked attack.

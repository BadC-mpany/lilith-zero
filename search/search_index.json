{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Lilith Zero","text":"<p>The Secure Middleware for Model Context Protocol (MCP)</p> <p> Bringing rigorous process isolation and security policy enforcement to AI Agent workflows. </p>"},{"location":"#what-is-lilith-zero","title":"What is Lilith Zero?","text":"<p>Lilith Zero is a security middleware designed for the Model Context Protocol (MCP). It acts as a secure proxy between your AI Agent (like Claude, ChatGPT, or LangChain) and the tools it uses.</p> <p>By intercepting all communication, Lilith Zero enforces:</p> <ol> <li>Process Isolation: Every tool runs in a strictly isolated environment (Windows Job Objects, macOS Re-Exec Supervisor, Linux Namespaces).</li> <li>Lethal Trifecta Protection: Prevents the dangerous combination of Private Data Access + Untrusted Computation + Exfiltration.</li> <li>Policy Enforcement: Granular control over what tools can be called and with what arguments.</li> </ol>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p>:material-shield-lock: Fail-Closed Security     ---     Default-deny architecture ensures that no tool runs without explicit permission.</p> </li> <li> <p>:material-eye: Deep Observability     ---     Full audit logs of every tool execution, argument, and output.</p> </li> <li> <p>:material-server-network: Process Supervision     ---     Automatic cleanup of zombie processes and resource limits enforcement.</p> </li> <li> <p>:material-file-document-edit: Declarative Policies     ---     Define security rules in simple YAML files.</p> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install Lilith Zero via cargo:</p> <pre><code>cargo install lilith-zero\n</code></pre> <p>Get Started Read the Docs &lt;\u0000!\u0000-\u0000-\u0000 \u0000t\u0000r\u0000i\u0000g\u0000g\u0000e\u0000r\u0000e\u0000d\u0000:\u0000 \u00000\u00002\u0000/\u00001\u00000\u0000/\u00002\u00000\u00002\u00006\u0000 \u00001\u00008\u0000:\u00001\u00005\u0000:\u00001\u00006\u0000 \u0000-\u0000-\u0000&gt;\u0000 \u0000 \u0000</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Lilith Zero! We welcome patches, bug reports, and feature requests.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>To work on Lilith Zero, you need a development environment with both Rust and Python.</p>"},{"location":"contributing/#1-rust-environment","title":"1. Rust Environment","text":"<p>We use standard <code>cargo</code> workflows.</p> <pre><code># Build the middleware\ncargo build\n</code></pre>"},{"location":"contributing/#2-python-environment-sdk","title":"2. Python Environment (SDK)","text":"<p>We use <code>uv</code> for Python dependency management.</p> <pre><code># Install dependencies\nuv pip install -e \"sdk[dev]\"\n</code></pre>"},{"location":"contributing/#3-running-tests","title":"3. Running Tests","text":"<p>We have a rigorous test suite.</p> <pre><code># Run Rust Unit Tests\ncargo test\n\n# Run Python SDK Tests\nuv run pytest sdk/tests/\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>The documentation (this site) is built with MkDocs Material.</p> <p>To run the documentation server locally:</p> <pre><code># Install docs dependencies\nuv pip install -r docs/requirements.txt\n\n# Run the server\nmkdocs serve\n</code></pre> <p>The site will be available at <code>http://127.0.0.1:8000</code>.</p>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<ul> <li>Rust: Run <code>cargo fmt</code> and <code>cargo clippy</code> before submitting.</li> <li>Python: We use <code>ruff</code> for linting and formatting.</li> </ul>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>Lilith Zero acts as a transparent security proxy for the Model Context Protocol (MCP). It sits between your AI Agent (the \"Client\") and the MCP Tools (the \"Server\").</p>"},{"location":"concepts/architecture/#high-level-overview","title":"High-Level Overview","text":"<p>The system is composed of three main layers:</p> <ol> <li>The Agent (Untrusted Core): Your LLM-driven application (LangChain, AutoGen, etc.).</li> <li>Lilith Zero (Trusted Middleware): The security boundary. It intercepts, audits, and supervises all traffic.</li> <li>The Tools (Sandboxed Execution): External binaries (Python scripts, Bash commands) that execute actual work.</li> </ol> <pre><code>graph TD\n    classDef trusted fill:#e1f5fe,stroke:#01579b,stroke-width:2px;\n    classDef untrusted fill:#ffebee,stroke:#b71c1c,stroke-width:2px;\n    classDef sandboxed fill:#f1f8e9,stroke:#33691e,stroke-width:2px;\n\n    Agent[AI Agent / LLM]:::untrusted\n    Middleware[Lilith Zero Middleware]:::trusted\n    tool_proc[Sandboxed Tool Process]:::sandboxed\n    audit_log[Audit Log]:::trusted\n    policy[Policy Engine]:::trusted\n\n    Agent -- \"Stdio / SSE\" --&gt; Middleware\n    Middleware -- \"Spawn &amp; Monitor\" --&gt; tool_proc\n    Middleware -.-&gt; audit_log\n    Middleware -.-&gt; policy\n\n    subgraph \"Trust Boundary\"\n        Middleware\n        audit_log\n        policy\n    end</code></pre>"},{"location":"concepts/architecture/#core-components","title":"Core Components","text":""},{"location":"concepts/architecture/#1-the-interceptor","title":"1. The Interceptor","text":"<p>Lilith Zero intercepts the <code>stdio</code> streams (stdin/stdout/stderr) of the MCP protocol. It parses every JSON-RPC message in real-time.</p> <ul> <li>Input Validation: Checks if the JSON is malformed.</li> <li>Policy Check: Consults the Policy Engine to see if the requested tool execution is allowed.</li> <li>Anonymization: Redacts PII (Personally Identifiable Information) from logs before writing them to disk.</li> </ul>"},{"location":"concepts/architecture/#2-the-policy-engine","title":"2. The Policy Engine","text":"<p>The Policy Engine is a deterministic state machine that enforces rules defined in <code>policies.yaml</code>.</p> <ul> <li>Allowlist/Blocklist: Controls which tools can be executed.</li> <li>Argument Filtering: Validates arguments against regex patterns (e.g., allow <code>ls</code> only on <code>/tmp</code>).</li> <li>Rate Limiting: Prevents denial-of-service via tool flooding.</li> </ul>"},{"location":"concepts/architecture/#3-the-process-supervisor","title":"3. The Process Supervisor","text":"<p>Unlike standard MCP implementations that just <code>spawn</code> a process, Lilith Zero acts as a Hypervisor for Tools.</p> <ul> <li>Zombie Protection: Uses OS-specific primitives (Job Objects on Windows, <code>kqueue</code> on macOS, <code>PR_SET_PDEATHSIG</code> on Linux) to ensure child processes always die when the parent dies.</li> <li>Resource Limits: Enforces CPU and Memory caps on tool processes.</li> <li>Isolation: Wraps tools in platform-specific sandboxes (e.g., AppContainer on Windows).</li> </ul>"},{"location":"concepts/process-isolation/","title":"Process Isolation &amp; Sandboxing","text":"<p>Lilith Zero implements rigorous, OS-specific mechanisms to ensure that tool compliance is not just a suggestion, but a kernel-enforced law.</p>"},{"location":"concepts/process-isolation/#windows-job-objects-appcontainers","title":"Windows: Job Objects &amp; AppContainers","text":"<p>On Windows, we utilize a multi-tiered defense strategy.</p>"},{"location":"concepts/process-isolation/#tier-1-job-objects","title":"Tier 1: Job Objects","text":"<p>Every tool spawned by Lilith Zero is assigned to a Windows Job Object.</p> <ul> <li>Lifecycle Management: The <code>JOBOBJECT_LIMIT_KILL_ON_JOB_CLOSE</code> flag ensures that if the Lilith Zero middleware crashes or is killed, Windows immediately terminates all child processes. No zombies, ever.</li> <li>Resource Limits: We apply strict memory and CPU time limits on the Job Object.</li> </ul>"},{"location":"concepts/process-isolation/#tier-2-restricted-tokens","title":"Tier 2: Restricted Tokens","text":"<p>We do not run tools with the user's full main token. Instead, we generate a Restricted Token:</p> <ul> <li>SID Filtering: We strip sensitive group memberships (e.g., Administrators).</li> <li>Privilege Stripping: We remove privileges like <code>SeDebugPrivilege</code> or <code>SeImpersonatePrivilege</code>.</li> <li>Integrity Level: We can lower the process integrity level to <code>Low</code> or <code>Untrusted</code>.</li> </ul>"},{"location":"concepts/process-isolation/#tier-3-appcontainers-experimental","title":"Tier 3: AppContainers (Experimental)","text":"<p>For maximum security, we support launching tools inside AppContainers\u2014the same sandbox technology used by UWP apps and Edge. This provides: -   Network Isolation: Blocked by default. -   Filesystem Virtualization: Writes are redirected to a virtual store.</p>"},{"location":"concepts/process-isolation/#macos-the-re-exec-supervisor","title":"macOS: The Re-Exec Supervisor","text":"<p>macOS lacks Windows' robust Job Objects, and standard <code>process_group</code> signaling is unreliable (tools can detach).</p> <p>To solve this, Lilith Zero implements the Re-Exec Supervisor Pattern:</p> <ol> <li>Self-Spawn: When you ask Lilith Zero to run a tool, it actually spawns a copy of itself in a special <code>__supervisor</code> mode.</li> <li>Kqueue Monitoring: This supervisor process uses <code>kqueue</code> EVFILT_PROC to monitor the parent (the middleware) and the child (the tool).</li> <li>Guaranteed Termination: If the parent process vanishes (crash or kill), the <code>kqueue</code> event fires instantly, and the supervisor explicitly <code>SIGKILL</code>s the tool before exiting itself.</li> </ol>"},{"location":"concepts/process-isolation/#linux-pr_set_pdeathsig","title":"Linux: PR_SET_PDEATHSIG","text":"<p>On Linux, we utilize the kernel's <code>prctl</code> interface. -   PDEATHSIG: We set <code>PR_SET_PDEATHSIG</code> to sends <code>SIGKILL</code> to the child process immediately if the parent process thread exits. -   Namespaces: (Planned) Verification using <code>unshare</code> to run tools in separate user/mount/network namespaces.</p>"},{"location":"concepts/security-model/","title":"Security Model: The Lethal Trifecta","text":"<p>The core design philosophy of Lilith Zero is built around mitigating the Lethal Trifecta of AI Agent risks.</p>"},{"location":"concepts/security-model/#the-lethal-trifecta","title":"The Lethal Trifecta","text":"<p>Classic security models focus on \"Malicious Users\" attacking \"Trusted Servers.\" In the Age of Agents, the threat model is inverted: Trusted Users are employing Untrusted Agents that have high-level capabilities.</p> <p>The \"Lethal Trifecta\" occurs when an Agent has:</p> <ol> <li>Private Data Access: Ability to read sensitive files (API keys, customer DBs, emails).</li> <li>Untrusted Computation: Ability to execute arbitrary code (Python interpreter, Shell scripts).</li> <li>Exfiltration Capability: Ability to send data to the outside world (Internet access, cURL).</li> </ol> <p>The Risk</p> <p>If an Agent possesses all three capabilities, it can be tricked (via Prompt Injection) into: 1. Reading your API keys (Private Data). 2. Processing them (Computation). 3. Sending them to an attacker (Exfiltration).</p>"},{"location":"concepts/security-model/#how-lilith-zero-mitigates-it","title":"How Lilith Zero Mitigates It","text":"<p>Lilith Zero breaks the trifecta by enforcing strict separation of concerns and principle of least privilege.</p>"},{"location":"concepts/security-model/#1-breaking-private-data-access","title":"1. Breaking \"Private Data Access\"","text":"<p>Lilith Zero enforces Filesystem isolation. Tools run in a sandbox that only sees a temporary workspace or strictly allowlisted directories. They cannot read <code>~/.ssh/id_rsa</code> or <code>.env</code> files unless you explicitly allow it.</p>"},{"location":"concepts/security-model/#2-breaking-untrusted-computation","title":"2. Breaking \"Untrusted Computation\"","text":"<p>We assume the LLM will try to run malicious code. -   Input Validation: Strict schema validation for tool arguments. -   Execution Limits: Tools have timeouts and memory limits. -   Sandboxing: Even if the tool is malicious, it runs in a Restricted Token context (Windows) or a restricted namespace (Linux), limiting the blast radius.</p>"},{"location":"concepts/security-model/#3-breaking-exfiltration","title":"3. Breaking \"Exfiltration\"","text":"<p>Lilith Zero acts as a network firewall for the Agent. -   Network Block by Default: Sandboxed processes have NO network access by default. -   Audit Logging: Every byte sent to <code>stdout</code> is logged. If data leaks, you have a forensic trail.</p>"},{"location":"concepts/security-model/#fail-closed-design","title":"Fail-Closed Design","text":"<p>Lilith Zero follows a Fail-Closed philosophy.</p> <ul> <li>If the policy file is missing -&gt; Deny All.</li> <li>If the policy file is malformed -&gt; Crash Safely (Panic).</li> <li>If the audit log cannot be written -&gt; Stop Execution.</li> </ul> <p>This ensures that the system never degrades into an insecure state.</p>"},{"location":"getting-started/","title":"Quickstart: Hello World","text":"<p>Let's build a secure \"Hello World\" agent using Lilith Zero. We will create a simple Python script that uses <code>curl</code> to fetch a webpage, and we will protect it with a policy.</p>"},{"location":"getting-started/#1-create-the-agent","title":"1. Create the Agent","text":"<p>Create a file named <code>agent.py</code>:</p> <pre><code>import subprocess\nimport sys\n\n# This is an \"unsafe\" agent that tries to access the internet\ndef main():\n    print(\"Agent: I am going to try and fetch google.com...\")\n    try:\n        result = subprocess.run(\n            [\"curl\", \"-I\", \"https://www.google.com\"], \n            capture_output=True, \n            text=True\n        )\n        print(f\"Agent: Success! Output:\\n{result.stdout}\")\n    except FileNotFoundError:\n        print(\"Agent: Failed to run curl.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"getting-started/#2-define-the-policy","title":"2. Define the Policy","text":"<p>Create a file named <code>policies.yaml</code> that allows <code>python</code> but blocks network access by default.</p> <pre><code>version: \"1.0\"\npolicies:\n  - name: \"Allow Python Agent\"\n    command: \"python\"\n    args: [\".*\"]\n    isolation:\n      network: false  # &lt;--- BLOCK THE INTERNET\n      filesystem: \"readonly\"\n</code></pre>"},{"location":"getting-started/#3-run-with-lilith-zero","title":"3. Run with Lilith Zero","text":"<p>Now, run the agent wrapped in the middleware:</p> <pre><code>lilith-zero --policy policies.yaml -- python agent.py\n</code></pre>"},{"location":"getting-started/#expected-output","title":"Expected Output","text":"<p>You should see the agent start, but the <code>curl</code> command inside it will fail (or hang/timeout depending on how <code>curl</code> handles network errors) because Lilith Zero blocked the network access at the process level.</p> <p>If you check the audit log, you'll see the violation.</p>"},{"location":"getting-started/#4-allow-access","title":"4. Allow Access","text":"<p>Edit <code>policies.yaml</code> to allow network:</p> <pre><code>    isolation:\n      network: true # &lt;--- ALLOW THE INTERNET\n</code></pre> <p>Run it again, and it should succeed!</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn how to Write granular policies.</li> <li>Explore the Architecture.</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>To use Lilith Zero, you need two components: 1.  The Middleware Binary (<code>lilith-zero</code>): The Rust-based security supervisor. 2.  The Python SDK (<code>lilith-zero-sdk</code>): The client library for your agents.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust Toolchain: Install Rust (1.75+)</li> <li>Python: Python 3.10 or higher.</li> <li>uv (Optional but recommended): High-performance Python package manager.</li> </ul>"},{"location":"getting-started/installation/#1-installing-the-middleware","title":"1. Installing the Middleware","text":"<p>You can install the middleware directly from crates.io or build it from source.</p> From Source (Recommended)Pre-built Binaries <p>Clone the repository and install via cargo:</p> <pre><code>git clone https://github.com/BadC-mpany/lilith-zero.git\ncd lilith-zero\ncargo install --path lilith-zero\n</code></pre> <p>Verify the installation: <pre><code>lilith-zero --version\n</code></pre></p> <p>Check the GitHub Releases page for pre-compiled binaries for Windows, macOS, and Linux.</p>"},{"location":"getting-started/installation/#2-installing-the-python-sdk","title":"2. Installing the Python SDK","text":"<p>The SDK is available on PyPI.</p> <pre><code>pip install lilith-zero\n</code></pre> <p>Or using <code>uv</code>:</p> <pre><code>uv pip install lilith-zero\n\n# Or using uv project management\nuv add lilith-zero\n</code></pre>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":"OS Supported Isolation Mechanism Windows \u2705 Yes Job Objects, Restricted Tokens macOS \u2705 Yes Re-Exec Supervisor, <code>kqueue</code> Linux \u2705 Yes <code>PR_SET_PDEATHSIG</code>, Namespaces"},{"location":"guides/middleware-setup/","title":"Middleware Setup","text":"<p>This guide covers how to configure and run the <code>lilith-zero</code> middleware process.</p>"},{"location":"guides/middleware-setup/#cli-usage","title":"CLI Usage","text":"<p>The default usage wraps a command (like your agent script) and injects the middleware into its environment.</p> <pre><code>lilith-zero [OPTIONS] -- &lt;YOUR_COMMAND&gt; [ARGS]\n</code></pre>"},{"location":"guides/middleware-setup/#key-options","title":"Key Options","text":"Option Description Default <code>-p, --policy &lt;FILE&gt;</code> Path to the YAML policy file. <code>policies.yaml</code> <code>-a, --audit-log &lt;FILE&gt;</code> Path to write the JSON-L audit log. <code>audit.jsonl</code> <code>--enforce</code> Enable strict enforcement (Hard Fail). <code>true</code> <code>--dry-run</code> Log violations but do not block them (Audit Mode). <code>false</code>"},{"location":"guides/middleware-setup/#production-deployment","title":"Production Deployment","text":""},{"location":"guides/middleware-setup/#1-prepare-your-environment","title":"1. Prepare your Environment","text":"<p>Ensure that <code>lilith-zero</code> is in your <code>PATH</code> or available at a known location.</p>"},{"location":"guides/middleware-setup/#2-define-the-policy","title":"2. Define the Policy","text":"<p>Create a loose <code>policies.yaml</code> first, run your agent in <code>--dry-run</code> mode to collect usage patterns, and then tighten the policy.</p>"},{"location":"guides/middleware-setup/#3-run-the-supervisor","title":"3. Run the Supervisor","text":"<p>Launch your agent under Lilith Zero's supervision.</p> <pre><code># Example: Running a LangChain agent\nlilith-zero --policy production-policies.yaml --audit-log /var/log/lilith/audit.jsonl -- python my_agent.py\n</code></pre>"},{"location":"guides/middleware-setup/#logging-observability","title":"Logging &amp; Observability","text":"<p>The audit log is a line-delimited JSON (JSON-L) file. Each line represents a tool execution attempt.</p> <pre><code>{\n  \"timestamp\": \"2023-10-27T10:00:00Z\",\n  \"event\": \"tool_execution\",\n  \"status\": \"blocked\",\n  \"reason\": \"policy_violation\",\n  \"command\": \"curl\",\n  \"args\": [\"http://evil.com\"],\n  \"policy_name\": null\n}\n</code></pre>"},{"location":"guides/red-teaming/","title":"Red Teaming &amp; Verification","text":"<p>Lilith Zero includes a comprehensive suite of Red Team tests to verify that your policies are actually enforcing security.</p>"},{"location":"guides/red-teaming/#the-red-team-suite","title":"The Red Team Suite","text":"<p>Located in <code>sdk/tests/red_team/</code>, this Python test suite simulates a compromised agent attempting the Lethal Trifecta.</p>"},{"location":"guides/red-teaming/#running-attacks-against-your-policy","title":"Running attacks against your Policy","text":"<p>You can run these tests against your specific <code>policies.yaml</code> to see if it holds up.</p> <pre><code># Install the SDK with test dependencies\nuv pip install -e \"sdk[test]\"\n\n# Run the attack suite\npytest sdk/tests/red_team/test_attacks.py\n</code></pre>"},{"location":"guides/red-teaming/#attack-vectors-tested","title":"Attack Vectors Tested","text":"<p>The suite attempts the following exploits:</p> <ol> <li>File Read: Attempts to read <code>/etc/passwd</code> (Linux) or <code>C:\\Windows\\win.ini</code>.</li> <li>File Write: Attempts to overwrite <code>policies.yaml</code> or creating persistence.</li> <li>Network Connect: Attempts <code>curl</code>, <code>wget</code>, or Python <code>requests</code> to external IPs.</li> <li>env leakage: Attempts to print environment variables (<code>printenv</code>).</li> <li>Fork Bomb: Attempts to crash the host via resource exhaustion (mitigated by Job Objects).</li> </ol>"},{"location":"guides/red-teaming/#interpretation-of-results","title":"Interpretation of Results","text":"<ul> <li>PASS: The attack failed (was blocked by Lilith Zero). This is Good.</li> <li>FAIL: The attack succeeded. Your policy is too permissive!</li> </ul> <p>Continuous Verification</p> <p>We recommend adding this Red Team step to your CI/CD pipeline. Every time you update <code>policies.yaml</code>, run the attacks to ensure no regressions.</p>"},{"location":"guides/writing-policies/","title":"Writing Policies","text":"<p>The security of your agent workflow depends on the quality of your policies. Lilith Zero uses a declarative YAML format to define what tools can run and how.</p>"},{"location":"guides/writing-policies/#policy-file-structure","title":"Policy File Structure","text":"<p>A policy file (<code>policies.yaml</code>) consists of a list of definitions, each targeting a specific tool or command pattern.</p> <pre><code># policies.yaml\nversion: \"1.0\"\npolicies:\n  - name: \"Allow Python Math\"\n    command: \"python\"\n    args: [\"-c\", \"print(.*)\"] # Regex matching\n    isolation:\n      network: false\n      filesystem: \"readonly\"\n\n  - name: \"Allow Current Date\"\n    command: \"date\"\n    args: []\n</code></pre>"},{"location":"guides/writing-policies/#policy-fields","title":"Policy Fields","text":""},{"location":"guides/writing-policies/#name-required","title":"<code>name</code> (Required)","text":"<p>A human-readable description of the policy rule. Useful for audit logs.</p>"},{"location":"guides/writing-policies/#command-required","title":"<code>command</code> (Required)","text":"<p>The exact binary name or path to the executable. - Example: <code>python</code>, <code>/usr/bin/git</code>, <code>node</code></p>"},{"location":"guides/writing-policies/#args-optional","title":"<code>args</code> (Optional)","text":"<p>A list of Regular Expressions that the arguments must match. - If omitted or empty, NO arguments are allowed (strict mode). - If you want to allow any argument, use <code>.*</code>. - Warning: Be careful with <code>.*</code>. It allows <code>rm -rf /</code> if applied to <code>bash</code>.</p>"},{"location":"guides/writing-policies/#isolation-optional","title":"<code>isolation</code> (Optional)","text":"<p>Defines the sandbox constraints for this tool.</p> Field Type Default Description <code>network</code> <code>bool</code> <code>false</code> Allow network access? <code>filesystem</code> <code>string</code> <code>\"none\"</code> <code>\"none\"</code>, <code>\"readonly\"</code>, or <code>\"readwrite\"</code> (workspace only) <code>cpu_limit</code> <code>float</code> <code>1.0</code> Max CPU cores (e.g., 0.5 for half core) <code>memory_limit_mb</code> <code>int</code> <code>512</code> Max RAM in Megabytes"},{"location":"guides/writing-policies/#example-secure-python-calculator","title":"Example: Secure Python Calculator","text":"<p>To allow an agent to use Python for math but prevent it from accessing files or the network:</p> <pre><code>policies:\n  - name: \"Safe Python Math\"\n    command: \"python\"\n    # Allow \"-c\" followed by simple math expressions (digits, operators)\n    args: \n      - \"-c\"\n      - \"^print\\\\([0-9+\\\\-*/\\\\s.]+\\\\)$\" \n    isolation:\n      network: false\n      filesystem: \"none\"\n</code></pre>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>The <code>lilith-zero</code> binary is the core entry point for the middleware.</p>"},{"location":"reference/cli/#usage","title":"Usage","text":"<pre><code>lilith-zero [OPTIONS] -- &lt;COMMAND&gt; [ARGS]...\n</code></pre>"},{"location":"reference/cli/#options","title":"Options","text":""},{"location":"reference/cli/#-policy-file","title":"<code>--policy &lt;FILE&gt;</code>","text":"<ul> <li>Description: Path to the YAML policy file defining allowed tools.</li> <li>Default: <code>policies.yaml</code></li> <li>Env Var: <code>LILITH_POLICY</code></li> </ul>"},{"location":"reference/cli/#-audit-log-file","title":"<code>--audit-log &lt;FILE&gt;</code>","text":"<ul> <li>Description: Path to the output audit log file (JSON-L format).</li> <li>Default: <code>audit.jsonl</code></li> <li>Env Var: <code>LILITH_AUDIT_LOG</code></li> </ul>"},{"location":"reference/cli/#-enforce","title":"<code>--enforce</code>","text":"<ul> <li>Description: If set, Lilith Zero will block any policy violations. If unset (or if <code>--dry-run</code> is used), it will only log them.</li> <li>Default: <code>true</code> (Enforcement is ON by default).</li> </ul>"},{"location":"reference/cli/#-dry-run","title":"<code>--dry-run</code>","text":"<ul> <li>Description: Alias for disabling enforcement. Useful for learning tool usage patterns before locking them down.</li> </ul>"},{"location":"reference/cli/#-parent-pid-pid","title":"<code>--parent-pid &lt;PID&gt;</code>","text":"<ul> <li>Description: (Internal) Used by the Supervisor mode to track the parent process ID. Do not use manually.</li> </ul>"},{"location":"reference/cli/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code>: Success.</li> <li><code>1</code>: General Error (Configuration, Policy missing).</li> <li><code>101</code>: Middleware Panic (Bug).</li> <li><code>137</code>: Process Killed by Supervisor (OOM or Policy Violation).</li> </ul>"},{"location":"reference/sdk/","title":"Python SDK Reference","text":"<p>Lilith SDK - Secure MCP Middleware for AI Agents.</p> <p>This module provides the core Lilith class for wrapping MCP tool servers with policy enforcement, session security, and process isolation.</p> Example <p>async with Lilith(\"python mcp_server.py\", policy=\"policy.yaml\") as s:     tools = await s.list_tools()     result = await s.call_tool(\"my_tool\", {\"arg\": \"value\"})</p> <p>Copyright 2026 BadCompany. All Rights Reserved.</p>"},{"location":"reference/sdk/#lilith_zero.client.Lilith","title":"<code>Lilith</code>","text":"<p>Lilith Security Middleware for AI Agents.</p> <p>Wraps an upstream MCP tool server with policy enforcement, session integrity, and optional process sandboxing.</p> <p>Attributes:</p> Name Type Description <code>session_id</code> <code>str | None</code> <p>The HMAC-signed session identifier (set after connect).</p> Source code in <code>sdk/src/lilith_zero/client.py</code> <pre><code>class Lilith:\n    \"\"\"Lilith Security Middleware for AI Agents.\n\n    Wraps an upstream MCP tool server with policy enforcement, session integrity,\n    and optional process sandboxing.\n\n    Attributes:\n        session_id: The HMAC-signed session identifier (set after connect).\n    \"\"\"\n\n    def __init__(\n        self,\n        upstream: str | None = None,\n        *,\n        policy: str | None = None,\n        binary: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize Lilith middleware configuration.\n\n        Args:\n            upstream: Command to run the upstream MCP server (e.g., \"python server.py\").\n                      If None, Lilith starts in a mode waiting for connection (future).\n                      Currently required.\n            policy: Path to policy YAML file for rule-based enforcement.\n            binary: Path to Lilith binary (auto-discovered if not provided).\n\n        Raises:\n            LilithConfigError: If upstream is empty or binary not found.\n        \"\"\"\n        if not upstream or not upstream.strip():\n            raise LilithConfigError(\n                \"Upstream command is required in this version.\", config_key=\"upstream\"\n            )\n\n        import platform\n        import shlex\n\n        # Parse upstream command robustly\n        try:\n            # On Windows, posix=False is required to preserve backslashes\n            is_posix = platform.system() != \"Windows\"\n            parts = shlex.split(upstream.strip(), posix=is_posix)\n        except ValueError as e:\n            raise LilithConfigError(\n                f\"Malformed upstream command: {e}\", config_key=\"upstream\"\n            ) from e\n\n        if not parts:\n            raise LilithConfigError(\n                \"Upstream command is empty after parsing.\", config_key=\"upstream\"\n            )\n\n        self._upstream_cmd = parts[0]\n        self._upstream_args = parts[1:] if len(parts) &gt; 1 else []\n\n        # Resolve binary path\n        try:\n            self._binary_path = binary or _find_binary()\n        except LilithConfigError:\n            # Re-raise with clean message\n            raise\n\n        if not os.path.exists(self._binary_path):\n            raise LilithConfigError(\n                f\"Lilith binary not found at {self._binary_path}\", config_key=\"binary\"\n            )\n\n        self._binary_path = os.path.abspath(self._binary_path)\n\n        # Policy configuration\n        self._policy_path = os.path.abspath(policy) if policy else None\n\n        # Runtime state\n        self._process: asyncio.subprocess.Process | None = None\n        self._reader_task: asyncio.Task[None] | None = None\n        self._stderr_task: asyncio.Task[None] | None = None\n        self._session_id: str | None = None\n        self._session_event = asyncio.Event()\n        self._pending_requests: dict[str, asyncio.Future[Any]] = {}\n        self._lock = asyncio.Lock()\n\n    @property\n    def session_id(self) -&gt; str | None:\n        \"\"\"The HMAC-signed session identifier.\"\"\"\n        return self._session_id\n\n    @staticmethod\n    def install_binary() -&gt; None:\n        \"\"\"Helper to invoke the installer interactively.\"\"\"\n        install_lilith(interactive=True)\n\n    # -------------------------------------------------------------------------\n    # Async Context Manager Protocol\n    # -------------------------------------------------------------------------\n\n    async def __aenter__(self) -&gt; \"Lilith\":\n        await self._connect()\n        return self\n\n    async def __aexit__(\n        self,\n        _exc_type: type[BaseException] | None,\n        _exc_val: BaseException | None,\n        _exc_tb: Any,\n    ) -&gt; None:\n        await self._disconnect()\n\n    # -------------------------------------------------------------------------\n    # Public API\n    # -------------------------------------------------------------------------\n\n    async def list_tools(self) -&gt; list[ToolRef]:\n        \"\"\"Fetch available tools from the upstream MCP server.\"\"\"\n        response = await self._send_request(\"tools/list\", {})\n        tools = response.get(\"tools\", [])\n        return cast(list[ToolRef], tools)\n\n    async def call_tool(self, name: str, arguments: dict[str, Any]) -&gt; ToolResult:\n        \"\"\"Execute a tool call through Lilith policy enforcement.\n\n        Raises:\n            PolicyViolationError: If blocked by policy.\n            LilithProcessError: If communication fails.\n        \"\"\"\n        payload = {\"name\": name, \"arguments\": arguments}\n        result = await self._send_request(\"tools/call\", payload)\n        return cast(ToolResult, result)\n\n    async def list_resources(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Fetch available resources from the upstream MCP server.\"\"\"\n        response = await self._send_request(\"resources/list\", {})\n        result: list[dict[str, Any]] = response.get(\"resources\", [])\n        return result\n\n    async def read_resource(self, uri: str) -&gt; dict[str, Any]:\n        \"\"\"Read a resource through Lilith policy enforcement.\"\"\"\n        payload = {\"uri\": uri}\n        result: dict[str, Any] = await self._send_request(\"resources/read\", payload)\n        return result\n\n    # -------------------------------------------------------------------------\n    # Connection Management (Private)\n    # -------------------------------------------------------------------------\n\n    async def _connect(self) -&gt; None:\n        cmd = self._build_command()\n        _logger.info(\"Spawning Lilith: %s\", \" \".join(cmd))\n\n        try:\n            self._process = await asyncio.create_subprocess_exec(\n                *cmd,\n                stdin=asyncio.subprocess.PIPE,\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE,\n            )\n        except OSError as e:\n            raise LilithConnectionError(\n                f\"Failed to spawn Lilith: {e}\",\n                phase=\"spawn\",\n                underlying_error=e,\n            ) from e\n\n        # Start background readers\n        self._reader_task = asyncio.create_task(self._read_stdout_loop())\n        self._stderr_task = asyncio.create_task(self._read_stderr_loop())\n\n        try:\n            # Wait for session ID\n            await self._wait_for_session()\n\n            # MCP handshake\n            _logger.info(\"Performing MCP handshake...\")\n            await self._send_request(\n                \"initialize\",\n                {\n                    \"protocolVersion\": _MCP_PROTOCOL_VERSION,\n                    \"capabilities\": {},\n                    \"clientInfo\": {\"name\": _SDK_NAME, \"version\": _SDK_VERSION},\n                },\n            )\n            await self._send_notification(\"notifications/initialized\", {})\n            _logger.info(\"Handshake complete. Session: %s\", self._session_id)\n        except Exception:\n            # If handshake fails, ensure we clean up processes\n            await self._disconnect()\n            raise\n\n    async def _disconnect(self) -&gt; None:\n        if self._reader_task:\n            self._reader_task.cancel()\n        if self._stderr_task:\n            self._stderr_task.cancel()\n\n        if self._process:\n            try:\n                self._process.terminate()\n                await asyncio.wait_for(self._process.wait(), timeout=5.0)\n            except (ProcessLookupError, asyncio.TimeoutError):\n                with contextlib.suppress(ProcessLookupError):\n                    self._process.kill()\n\n        self._session_id = None\n        self._session_event.clear()  # Clear the event for future connections\n\n    def _build_command(self) -&gt; list[str]:\n        if not self._binary_path or not self._upstream_cmd:\n            raise LilithConfigError(\"Invalid configuration for build_command\")\n\n        cmd: list[str] = [self._binary_path]\n\n        if self._policy_path:\n            cmd.extend([\"--policy\", self._policy_path])\n\n        cmd.extend([\"--upstream-cmd\", self._upstream_cmd])\n        if self._upstream_args:\n            cmd.append(\"--\")\n            cmd.extend(self._upstream_args)\n\n        return cmd\n\n    async def _wait_for_session(self) -&gt; None:\n        \"\"\"Wait for session ID to be captured from stderr.\"\"\"\n        try:\n            # Wait for the reader task to find the session ID\n            # Use a slightly longer timeout than the handshake itself to be safe\n            await asyncio.wait_for(\n                self._session_event.wait(), timeout=_SESSION_TIMEOUT_SEC\n            )\n        except asyncio.TimeoutError as e:\n            # Rigour: check if the process died while we were waiting\n            if self._process and self._process.returncode is not None:\n                # Read remaining stderr to give a clue\n                err_msg = \"\"\n                if self._process.stderr:\n                    err_bytes = await self._process.stderr.read()\n                    err_msg = err_bytes.decode(errors=\"ignore\")\n\n                raise LilithProcessError(\n                    f\"Lilith process exited early with code {self._process.returncode}\",\n                    exit_code=self._process.returncode,\n                    stderr=err_msg,\n                ) from e\n\n            raise LilithConnectionError(\n                f\"Handshake timeout after {_SESSION_TIMEOUT_SEC}s\",\n                phase=\"handshake\",\n            ) from e\n\n    # -------------------------------------------------------------------------\n    # I/O Handling (Private)\n    # -------------------------------------------------------------------------\n\n    async def _read_stderr_loop(self) -&gt; None:\n        if not self._process or not self._process.stderr:\n            return\n\n        try:\n            while True:\n                line_bytes = await self._process.stderr.readline()\n                if not line_bytes:\n                    break\n\n                text = line_bytes.decode().strip()\n                if _SESSION_ID_MARKER in text:\n                    parts = text.split(_SESSION_ID_MARKER)\n                    if len(parts) &gt; 1:\n                        self._session_id = parts[1].strip()\n                        self._session_event.set()\n                        _logger.debug(\"Captured session ID: %s\", self._session_id)\n                else:\n                    _logger.debug(\"[stderr] %s\", text)\n        except asyncio.CancelledError:\n            pass\n\n    async def _read_stdout_loop(self) -&gt; None:\n        if not self._process or not self._process.stdout:\n            return\n\n        try:\n            while True:\n                # 1. Read Headers\n                headers = {}\n                while True:\n                    # Rigour: readline with a limit to avoid memory bloat\n                    # on malformed input\n                    line_bytes = await self._process.stdout.readline()\n                    if not line_bytes:\n                        return  # EOF\n\n                    if len(line_bytes) &gt; _MAX_HEADER_LINE_LENGTH:\n                        _logger.error(\n                            \"Header line too long (%d bytes)\", len(line_bytes)\n                        )\n                        await self._disconnect_with_error(\n                            \"Protocol violation: header too long\"\n                        )\n                        return\n\n                    line = line_bytes.decode().strip()\n                    if not line:\n                        # End of headers (empty line)\n                        break\n\n                    if \":\" in line:\n                        key, value = line.split(\":\", 1)\n                        headers[key.lower().strip()] = value.strip()\n                    elif line.startswith(\"LILITH_ZERO_SESSION_ID=\"):\n                        self._session_id = line.split(\"=\", 1)[1]\n                        _logger.info(\"Session ID: %s\", self._session_id)\n                    else:\n                        _logger.debug(\"[stdout noise] %s\", line)\n\n                # 2. Check Content-Length\n                if \"content-length\" in headers:\n                    try:\n                        length = int(headers[\"content-length\"])\n\n                        # Rigour: sanity check length\n                        if length &gt; _MAX_PAYLOAD_SIZE:\n                            _logger.error(\"Payload too large (%d bytes)\", length)\n                            await self._disconnect_with_error(\n                                f\"Payload exceeds limit ({_MAX_PAYLOAD_SIZE})\"\n                            )\n                            return\n\n                        if length &gt; 0:\n                            body = await self._process.stdout.readexactly(length)\n                            msg = json.loads(body)\n                            _logger.debug(\n                                \"Received: %s\", body.decode(errors=\"replace\")[:1000]\n                            )\n                            if \"id\" in msg:\n                                self._dispatch_response(msg)\n                    except (\n                        ValueError,\n                        asyncio.IncompleteReadError,\n                        json.JSONDecodeError,\n                    ) as e:\n                        _logger.error(\"Failed to parse message: %s\", e)\n                        await self._disconnect_with_error(f\"Message corruption: {e}\")\n                        return\n                else:\n                    # Rigour: If we got noise but no content-length, we might be\n                    # out of sync. We continue for now, but in a production env,\n                    # we might want to be stricter.\n                    pass\n\n        except asyncio.CancelledError:\n            pass\n        except Exception as e:\n            _logger.exception(\"Uncaught error in reader loop: %s\", e)\n            await self._disconnect_with_error(str(e))\n        finally:\n            self._cleanup_pending_requests(\"Lilith process terminated unexpectedly\")\n\n    async def _disconnect_with_error(self, message: str) -&gt; None:\n        \"\"\"Helper to terminate connection on protocol error and notify callers.\"\"\"\n        _logger.error(\"Disconnecting due to error: %s\", message)\n\n        # If we are in the reader task, don't let _disconnect cancel us yet\n        current_task = asyncio.current_task()\n        reader_task = self._reader_task\n        if reader_task == current_task:\n            self._reader_task = None\n\n        await self._disconnect()\n        self._cleanup_pending_requests(message)\n\n        # If we were the reader task, we are done\n        if reader_task == current_task:\n            raise asyncio.CancelledError()\n\n    def _cleanup_pending_requests(self, message: str) -&gt; None:\n        \"\"\"Fail all pending requests with a descriptive error.\"\"\"\n        # Fail all futures that are still active\n        for req_id in list(self._pending_requests.keys()):\n            future = self._pending_requests.pop(req_id)\n            if not future.done():\n                future.set_exception(LilithProcessError(message))\n\n    def _dispatch_response(self, msg: dict[str, Any]) -&gt; None:\n        req_id = str(msg[\"id\"])\n        future = self._pending_requests.pop(req_id, None)\n        if future and not future.done():\n            if msg.get(\"error\"):\n                # Map standard JSON-RPC errors or specific Lilith codes\n                error_data = msg[\"error\"]\n                code = error_data.get(\"code\")\n                message = error_data.get(\"message\", \"Unknown error\")\n\n                # Check for Policy Violation (-32000 code or match string)\n                if \"Policy Violation\" in message or code == -32000:\n                    future.set_exception(\n                        PolicyViolationError(message, error_data.get(\"data\"))\n                    )\n                else:\n                    future.set_exception(\n                        LilithError(\n                            f\"Lilith RPC Error: {message}\",\n                            context={\"code\": code, \"data\": error_data.get(\"data\")},\n                        )\n                    )\n            else:\n                future.set_result(msg.get(\"result\", {}))\n\n    # -------------------------------------------------------------------------\n    # JSON-RPC Transport (Private)\n    # -------------------------------------------------------------------------\n\n    async def _send_notification(self, method: str, params: dict[str, Any]) -&gt; None:\n        if not self._process or not self._process.stdin:\n            raise LilithConnectionError(\"Lilith process not running\", phase=\"runtime\")\n\n        request = {\"jsonrpc\": \"2.0\", \"method\": method, \"params\": params}\n        body = json.dumps(request).encode(\"utf-8\")\n        header = f\"Content-Length: {len(body)}\\r\\n\\r\\n\".encode(\"ascii\")\n\n        async with self._lock:\n            try:\n                self._process.stdin.write(header + body)\n                await self._process.stdin.drain()\n            except (BrokenPipeError, ConnectionResetError) as e:\n                raise LilithConnectionError(\n                    \"Broken pipe to Lilith process\",\n                    phase=\"runtime\",\n                    underlying_error=e,\n                ) from e\n\n    async def _send_request(\n        self, method: str, params: dict[str, Any] | None = None\n    ) -&gt; Any:\n        # Check process status before even trying\n        if not self._process or self._process.returncode is not None:\n            raise LilithConnectionError(\n                \"Lilith process is not running\", phase=\"runtime\"\n            )\n\n        if not self._process.stdin:\n            raise LilithConnectionError(\"Lilith stdin is closed\", phase=\"runtime\")\n\n        req_id = str(uuid.uuid4())\n        if params is None:\n            params = {}\n        if self._session_id:\n            params[\"_lilith_zero_session_id\"] = self._session_id\n\n        request = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"params\": params,\n            \"id\": req_id,\n        }\n\n        future: Future[Any] = asyncio.Future()\n        self._pending_requests[req_id] = future\n\n        body = json.dumps(request).encode(\"utf-8\")\n        header = f\"Content-Length: {len(body)}\\r\\n\\r\\n\".encode(\"ascii\")\n\n        async with self._lock:\n            try:\n                self._process.stdin.write(header + body)\n                await self._process.stdin.drain()\n            except (BrokenPipeError, ConnectionResetError) as e:\n                self._pending_requests.pop(req_id, None)\n                raise LilithConnectionError(\n                    \"Broken pipe to Lilith process\",\n                    phase=\"runtime\",\n                    underlying_error=e,\n                ) from e\n\n        try:\n            return await asyncio.wait_for(future, timeout=30.0)\n        except asyncio.TimeoutError as e:\n            self._pending_requests.pop(req_id, None)\n            raise LilithError(f\"Request '{method}' timed out after 30s\") from e\n</code></pre>"},{"location":"reference/sdk/#lilith_zero.client.Lilith.session_id","title":"<code>session_id</code>  <code>property</code>","text":"<p>The HMAC-signed session identifier.</p>"},{"location":"reference/sdk/#lilith_zero.client.Lilith.__init__","title":"<code>__init__(upstream=None, *, policy=None, binary=None)</code>","text":"<p>Initialize Lilith middleware configuration.</p> <p>Parameters:</p> Name Type Description Default <code>upstream</code> <code>str | None</code> <p>Command to run the upstream MCP server (e.g., \"python server.py\").       If None, Lilith starts in a mode waiting for connection (future).       Currently required.</p> <code>None</code> <code>policy</code> <code>str | None</code> <p>Path to policy YAML file for rule-based enforcement.</p> <code>None</code> <code>binary</code> <code>str | None</code> <p>Path to Lilith binary (auto-discovered if not provided).</p> <code>None</code> <p>Raises:</p> Type Description <code>LilithConfigError</code> <p>If upstream is empty or binary not found.</p> Source code in <code>sdk/src/lilith_zero/client.py</code> <pre><code>def __init__(\n    self,\n    upstream: str | None = None,\n    *,\n    policy: str | None = None,\n    binary: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize Lilith middleware configuration.\n\n    Args:\n        upstream: Command to run the upstream MCP server (e.g., \"python server.py\").\n                  If None, Lilith starts in a mode waiting for connection (future).\n                  Currently required.\n        policy: Path to policy YAML file for rule-based enforcement.\n        binary: Path to Lilith binary (auto-discovered if not provided).\n\n    Raises:\n        LilithConfigError: If upstream is empty or binary not found.\n    \"\"\"\n    if not upstream or not upstream.strip():\n        raise LilithConfigError(\n            \"Upstream command is required in this version.\", config_key=\"upstream\"\n        )\n\n    import platform\n    import shlex\n\n    # Parse upstream command robustly\n    try:\n        # On Windows, posix=False is required to preserve backslashes\n        is_posix = platform.system() != \"Windows\"\n        parts = shlex.split(upstream.strip(), posix=is_posix)\n    except ValueError as e:\n        raise LilithConfigError(\n            f\"Malformed upstream command: {e}\", config_key=\"upstream\"\n        ) from e\n\n    if not parts:\n        raise LilithConfigError(\n            \"Upstream command is empty after parsing.\", config_key=\"upstream\"\n        )\n\n    self._upstream_cmd = parts[0]\n    self._upstream_args = parts[1:] if len(parts) &gt; 1 else []\n\n    # Resolve binary path\n    try:\n        self._binary_path = binary or _find_binary()\n    except LilithConfigError:\n        # Re-raise with clean message\n        raise\n\n    if not os.path.exists(self._binary_path):\n        raise LilithConfigError(\n            f\"Lilith binary not found at {self._binary_path}\", config_key=\"binary\"\n        )\n\n    self._binary_path = os.path.abspath(self._binary_path)\n\n    # Policy configuration\n    self._policy_path = os.path.abspath(policy) if policy else None\n\n    # Runtime state\n    self._process: asyncio.subprocess.Process | None = None\n    self._reader_task: asyncio.Task[None] | None = None\n    self._stderr_task: asyncio.Task[None] | None = None\n    self._session_id: str | None = None\n    self._session_event = asyncio.Event()\n    self._pending_requests: dict[str, asyncio.Future[Any]] = {}\n    self._lock = asyncio.Lock()\n</code></pre>"},{"location":"reference/sdk/#lilith_zero.client.Lilith.call_tool","title":"<code>call_tool(name, arguments)</code>  <code>async</code>","text":"<p>Execute a tool call through Lilith policy enforcement.</p> <p>Raises:</p> Type Description <code>PolicyViolationError</code> <p>If blocked by policy.</p> <code>LilithProcessError</code> <p>If communication fails.</p> Source code in <code>sdk/src/lilith_zero/client.py</code> <pre><code>async def call_tool(self, name: str, arguments: dict[str, Any]) -&gt; ToolResult:\n    \"\"\"Execute a tool call through Lilith policy enforcement.\n\n    Raises:\n        PolicyViolationError: If blocked by policy.\n        LilithProcessError: If communication fails.\n    \"\"\"\n    payload = {\"name\": name, \"arguments\": arguments}\n    result = await self._send_request(\"tools/call\", payload)\n    return cast(ToolResult, result)\n</code></pre>"},{"location":"reference/sdk/#lilith_zero.client.Lilith.install_binary","title":"<code>install_binary()</code>  <code>staticmethod</code>","text":"<p>Helper to invoke the installer interactively.</p> Source code in <code>sdk/src/lilith_zero/client.py</code> <pre><code>@staticmethod\ndef install_binary() -&gt; None:\n    \"\"\"Helper to invoke the installer interactively.\"\"\"\n    install_lilith(interactive=True)\n</code></pre>"},{"location":"reference/sdk/#lilith_zero.client.Lilith.list_resources","title":"<code>list_resources()</code>  <code>async</code>","text":"<p>Fetch available resources from the upstream MCP server.</p> Source code in <code>sdk/src/lilith_zero/client.py</code> <pre><code>async def list_resources(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Fetch available resources from the upstream MCP server.\"\"\"\n    response = await self._send_request(\"resources/list\", {})\n    result: list[dict[str, Any]] = response.get(\"resources\", [])\n    return result\n</code></pre>"},{"location":"reference/sdk/#lilith_zero.client.Lilith.list_tools","title":"<code>list_tools()</code>  <code>async</code>","text":"<p>Fetch available tools from the upstream MCP server.</p> Source code in <code>sdk/src/lilith_zero/client.py</code> <pre><code>async def list_tools(self) -&gt; list[ToolRef]:\n    \"\"\"Fetch available tools from the upstream MCP server.\"\"\"\n    response = await self._send_request(\"tools/list\", {})\n    tools = response.get(\"tools\", [])\n    return cast(list[ToolRef], tools)\n</code></pre>"},{"location":"reference/sdk/#lilith_zero.client.Lilith.read_resource","title":"<code>read_resource(uri)</code>  <code>async</code>","text":"<p>Read a resource through Lilith policy enforcement.</p> Source code in <code>sdk/src/lilith_zero/client.py</code> <pre><code>async def read_resource(self, uri: str) -&gt; dict[str, Any]:\n    \"\"\"Read a resource through Lilith policy enforcement.\"\"\"\n    payload = {\"uri\": uri}\n    result: dict[str, Any] = await self._send_request(\"resources/read\", payload)\n    return result\n</code></pre>"},{"location":"reference/sdk/#lilith_zero.client.LilithError","title":"<code>LilithError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all Lilith SDK errors.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>A human-readable error message.</p> <code>context</code> <p>Optional dictionary containing debugging metadata.</p> Source code in <code>sdk/src/lilith_zero/exceptions.py</code> <pre><code>class LilithError(Exception):\n    \"\"\"Base class for all Lilith SDK errors.\n\n    Attributes:\n        message: A human-readable error message.\n        context: Optional dictionary containing debugging metadata.\n    \"\"\"\n\n    def __init__(self, message: str, context: dict[str, Any] | None = None) -&gt; None:\n        super().__init__(message)\n        self.message = message\n        self.context = context or {}\n\n    def __str__(self) -&gt; str:\n        if self.context:\n            return f\"{self.message} (context: {self.context})\"\n        return self.message\n</code></pre>"},{"location":"reference/sdk/#lilith_zero.client.PolicyViolationError","title":"<code>PolicyViolationError</code>","text":"<p>               Bases: <code>LilithError</code></p> <p>Raised when a tool execution is blocked by the security policy.</p> Source code in <code>sdk/src/lilith_zero/exceptions.py</code> <pre><code>class PolicyViolationError(LilithError):\n    \"\"\"Raised when a tool execution is blocked by the security policy.\"\"\"\n\n    def __init__(\n        self, message: str, policy_details: dict[str, Any] | None = None\n    ) -&gt; None:\n        super().__init__(message, context={\"policy_details\": policy_details or {}})\n        self.policy_details: dict[str, Any] = policy_details or {}\n</code></pre>"}]}
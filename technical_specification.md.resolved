# Sentinel: MCP Security Middleware

**Technical Specification v2.0 (Resolved)**

---

## 1. Overview

Sentinel is a high-assurance security middleware for the [Model Context Protocol (MCP)](https://spec.modelcontextprotocol.io/specification/2024-11-05/). It interposes between an MCP client (e.g., Claude Desktop, LangChain agent) and an upstream MCP tool server, providing **Process Isolation**, **Taint Tracking**, and **Policy Enforcement** with <1ms latency.

### 1.1 Architecture

```mermaid
graph LR
    subgraph "Application Layer"
        A[LLM Agent]
    end
    subgraph "Python SDK"
        B[SentinelClient]
    end
    subgraph "Rust Middleware (stdio JSON-RPC)"
        direction TB
        C[Actor Core]
        D[PolicyEvaluator]
        E[Sandbox Supervisor]
        F[SecurityEngine]
    end
    subgraph "Upstream (Sandboxed)"
        G[MCP Tool Server]
    end

    A --> B
    B -- "JSON-RPC 2.0" --> C
    C <--> D
    C <--> F
    C -- "Lifecycle" --> E
    E -- "Process/Job" --> G
```

### 1.2 Key Properties

| Property | Implementation |
|----------|----------------|
| **Transport** | stdio (newline-delimited JSON-RPC 2.0) |
| **Session Integrity** | HMAC-SHA256 signed session IDs |
| **Access Control** | Static ACL + Taint Propagation + Resource Globbing |
| **Prompt Injection** | Randomized spotlighting delimiters |
| **Process Isolation** | **Tiered Adaptive Sandbox** (Win) / `landlock` (Linux) |
| **Observability** | Structured JSON audit logs to stderr |

---

## 2. Rust Middleware

**Location:** `sentinel/src/`  
**Entry Point:** `main.rs`  
**Binary:** `sentinel.exe`

### 2.1 Module Structure

```
sentinel/src/
├── main.rs          # Entry point, tokio runtime
├── config.rs        # Configuration
├── core/
│   ├── auth.rs      # Audience binding
│   ├── crypto.rs    # HMAC session signing
│   ├── errors.rs    # Error mapping
│   └── models.rs    # PolicyDefinition, ToolCall, Decision
├── engine/
│   ├── evaluator.rs # Policy logic (Static, Taint, Resource)
│   └── pattern_matcher.rs # JsonLogic AST
├── mcp/
│   ├── server.rs    # Actor Model (Tokio MPSC)
│   ├── transport.rs # Async Stdio (Framed/Line)
│   ├── security.rs  # Spotlighting
│   └── sandbox/     # SANDBOX SUBSYSTEM
│       ├── mod.rs   # ChildProcess Trait, SandboxPolicy
│       ├── windows.rs # Tier 1 (AppContainer) & Tier 2 (Job+Token)
│       └── profiles.rs # Runtime profiles (Python, Node)
└── utils/
    └── audit_logger.rs # Structured Logging
```

### 2.2 Tiered Adaptive Sandbox (Windows)

Sentinel implements a "Google-Grade" adaptive security model that automatically selects the highest secure tier compatible with the target tool.

| Tier | Technology | Security Model | Use Case |
| :--- | :--- | :--- | :--- |
| **Tier 1 (Ironclad)** | `AppContainer` | **Zero Trust**. Network Blocked. Read-only whitelist access to files. | User-owned dependencies (local venv). |
| **Tier 2 (Safety Net)** | `Restricted Token` | **High Integrity**. `DISABLE_MAX_PRIVILEGE` (Strips Admin). `LUA_TOKEN`. Write-blocked via MIC. | System Runtimes (Miniconda, Global Python) that require User Profile traversal. |

**Containment Mechanisms:**
1.  **Job Objects**: Enforce `JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE`.
2.  **Tokens**: Hardened via `CreateRestrictedToken`.
3.  **Permissions**: DACL modifications for Low/Medium Integrity Traversal.

### 2.3 Policy Definition

**File:** [models.rs](sentinel/src/core/models.rs)

```yaml
id: "hardened-policy"
version: 1
sandbox:
  allow_network: false
  read_paths: ["C:/Projects/Secrets"]
  write_paths: ["C:/Projects/Output"]
  allow_env: ["PYTHONPATH"]

staticRules:
  read_file: "ALLOW"
  exec_shell: "DENY"

taintRules:
  - tool: "read_secret"
    action: "ADD_TAINT"
    tag: "CONFIDENTIAL"
  - tool: "upload_data"
    action: "CHECK_TAINT"
    forbidden_tags: ["CONFIDENTIAL"]
    error: "Exfiltration blocked."
```

---

## 3. Python SDK

**Package:** `sentinel_sdk`  
**Version:** 0.1.0

### 3.1 Sentinel Client (`sentinel_sdk.Sentinel`)

Implements the "Facade" pattern to manage the middleware lifecycle.

```python
async with Sentinel(
    upstream="python server.py",
    policy="policy.yaml",
    security_level="high"
) as client:
    result = await client.execute_tool("calculator", {"a": 1, "b": 2})
```

**Lifecycle:**
1.  **Spawn**: Launches `sentinel.exe` with config args.
2.  **Handshake**: Exchanges capabilities and Session ID.
3.  **Binding**: All subsequent calls sign requests with `_sentinel_session_id`.
4.  **Termination**: Cleanup via `SIGTERM` / handle closure.

---

## 4. Security Mechanics

### 4.1 Taint Tracking
- **Tag Propagation**: Taints are sets of strings (`HashSet<String>`) attached to the *Session*.
- **Persistence**: Taint state persists for the duration of the Sentinel session (lifetime of the upstream tool).
- **Enforcement**: Checked *before* every tool execution.

### 4.2 Spotlighting
- **Defense**: Prevents LLM Prompt Injection by wrapping tool output.
- **Format**: `<<<SENTINEL_DATA_START:{8_CHAR_RANDOM_ID}>>> ... <<<...END...>>>`
- **Verification**: The SDK strips these delimiters before returning to the Agent logic, ensuring the Agent never sees raw, potentially malicious delimiters.

### 4.3 Audit Logging
Structured logs emitted to `stderr` (separate from `stdout` transport pipeline).

```json
{
  "timestamp": 1709251200,
  "event_type": "Decision",
  "tool": "write_file",
  "decision": "DENIED",
  "reason": "Path not in sandbox write list"
}
```

---

## 5. Build & Verification

### 5.1 Prerequisites
- **Rust**: 1.70+
- **Python**: 3.10+
- **OS**: Windows 10/11 (for Sandbox), Linux (Limited)

### 5.2 Compilation
```bash
cargo build --release
# Output: target/release/sentinel.exe
```

### 5.3 Test Suite
- `tests/test_basic_flow.py`: Connectivity check.
- `tests/test_security_hardening.py`: Policy enforcement verification.
- `examples/react_agent_demo/demo.py`: End-to-End Sandbox integration test.
